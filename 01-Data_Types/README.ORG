#+TITLE: HA's GNU Emacs Config
#+AUTHOR: Hussain Almalki (HA)
#+DESCRIPTION: Data Types
#+STARTUP: showeverything
#+OPTIONS: toc:2

* TABLE OF CONTENTS :toc:
- [[#fundamental-data-types---integer][Fundamental Data Types - Integer]]
  - [[#size-of-integer][SIZE OF INTEGER]]
  - [[#summary][SUMMARY]]
- [[#exceeding-the-valid-range-of-data-tpes][Exceeding the Valid Range of Data Tpes]]
  - [[#outline][OUTLINE]]
- [[#fundamental-data-types---character][Fundamental Data Types - Character]]
  - [[#outline-1][OUTLINE]]
  - [[#overview][OVERVIEW]]
  - [[#size-and-range-of-character][SIZE AND RANGE OF CHARACTER]]
  - [[#signed-vs-unsigned][SIGNED VS UNSIGNED]]
  - [[#summary-1][SUMMARY]]

* Fundamental Data Types - Integer
We have various data types to study. And today we begin our session with ~integer Data Type~.
** SIZE OF INTEGER
| 2 bytes | 16 bits |
| 4 bytes | 32 bits |

*** WANNA KNOW SIZE PROGRAMMATICALLY?
- Use ~sizeof~ operator
#+begin_src c
#include <stdio.h>

int main(){
  printf("%d", sizeof(int));
  return 0;
}
#+end_src
*Note:* sizeof is a unary operator and not function.
#+begin_src output
4
#+end_src

*** RANGE
*Range:* upper and lower limit of some set of data.
FOR EXAMPLE: {0,1,2,3,4}
Range: 0 to 4

*** PREREQUSITES
*Decimal number system:* Human Understandabel number system.
Also called as ~base 10~ number system.
*Range:* 0 to 9
FOR EXAMPLE: 5 6 8
10^2 x 5 + 10^1 x 6 + 10^0 x 8 = 500 + 60 + 8 = 568

*Binary number system:* Machine Understandable number system.
Also called as ~base 2~ number system.
*Range:* 0 to 1
FOR EXAMPLE: 1100
2^3 x 1 + 2^2 x 1 + 2^1 x 0 + 2^0 x 0 = 8 + 4 + 0 + 0 = 12

*** RANGE OF 4 BIT DATA?
Now what would be the range of 4 bit data? As we know, to calculate range of any nubmer we have to know its minimum, as well as maximum value. For 4 bit data, minimum value is equals to 0. And maximum value is equals to 15.

4 bit data: 0000 minimum value = 0
4 bit data: 1111 maximum value = 15
Range of 4 bit data: 0000 to 1111
*FORMULA:* ~2^n - 1~

*** RANGE OF INTEGER
The size of integer is of 2 bytes,
(2 bytes) [16 bits]
- Unsgned range: 0 to 65535 ( by applying: 2^n - 1)
- Signed range: -32768 to +32767
- 2's complement range: -(2^n-1) to +(2^n-1 - 1)
(4 bytes) [32 bits]
- Unsigned range: 0 to 4294967295 (by applying: 2^n -1)
- Signed range: -2147493648 to +2147483647

*** OUTLINE
- Modifiers (short,long,signed,unsigned) used for integer.
- Some programming examples.

*** LONG AND SHORT
These are the modifiers used to make it possible for a data type to take either less or more memory. ~If integer is 4 bytes, short int may be 2 bytes~.
Size of short integer is of 2 bytes. As you can see, the output is 2.
#+begin_src c
#include <stdio.h>

int main(){
  printf("%d", sizeof(short int));
  return 0;
}
#+end_src
Output:
#+begin_src output
2
#+end_src
On the other hand, using long as a modifier in front of integer allows integer data type to take more memory space. Here you can see output is 8.
#+begin_src c
#include <stdio.h>

int main(){
  printf("%d", sizeof(long int));
  return 0;
}
#+end_src
Output:
#+begin_src 
8
#+end_src

sizeof(short) <= sizeof(int) <= sizeof(long)
*NOTE:* by default int some_variable_name; is signed integer variable.
Unsigned int some_variable_name; allows only positive values.

*** PROGRAMMING EXAMPLES
First of all, I have included a new header file limits.h. This header file consists of some symbolic constants, that are useful in determining the minimum as well as the maximum valuse.
#+begin_src c
#include <stdio.h>
#include <limits.h>

int main(){
  int var1 = INT_MIN;
  int var2 = INT_MAX;

  printf("range of signed integer is from: %d to %d", var1, var2);
  return 0;
}
#+end_src
Output:
#+begin_src output
range of signed integer is from: -2147483648 to 2147483647
#+end_src

#+begin_src c
#include <stdio.h>
#include <limits.h>

int main(){
  unsigned int var1 = 0;
  unsigned int var2 = UINT_MAX;

  printf("range of unsigned integer is from: %u to %u", var1, var2);
  return 0;
}
#+end_src
Output:
#+begin_src output
range of signed integer is from: 0 to 4294967295
#+end_src

#+begin_src c
#include <stdio.h>
#include <limits.h>

int main(){
  short int var1 = SHRT_MIN;
  short int var2 = SHRT_MAX;

  printf("range of short signed integer is from: %d to %d", var1, var2);
  return 0;
}
#+end_src
Output:
#+begin_src output
range of short signed integer is from: -32768 to 32767
#+end_src

#+begin_src c
#include <stdio.h>
#include <limits.h>

int main(){
  short unsigned int var1 = 0;
  short unsigned int var2 = USHRT_MAX;

  printf("range of short unsigned integer is from: %u to %u", var1, var2);
  return 0;
}
#+end_src
Output:
#+begin_src output
range of short signed integer is from: 0 to 65535
#+end_src

if sizeof(long int) = 4 bytes
then sizeof(long long int) = 8 bytes
else
if sizeof(long int) = 8 bytes
then sizeof(long long int) = 8 bytes

** SUMMARY
- sizeof(short) <= sizeof(int) <= sizeof(long).
- Writing signed int some_variable_name; is equivalent to writing int some_variable_name;
- %d is used to print "signed integer".
- %u is used to print "unsigned integer".
- %ld is used to print "long integer" equivalent to "signed long integer".
- %lu is used to print "unsigned long integer".
- %lld is used to print "long long integer".
- %llu is used to print "unsigned long long integer".

* Exceeding the Valid Range of Data Tpes
** OUTLINE
- Exceeding the unsigned range
- Exceeding the signed range

  here int this example I had provided an indigent variable and that to an unsigned integer variable and assigned it a value 4294967295 which is the maximum allowable value of an unsigned integer.

#+begin_src c
#include <stdio.h>

int main(){
  unsigned int var = 4294967295;
  printf("%u", var);
  return 0;
}
#+end_src
Output:
#+begin_src output
4294967295
#+end_src

When we chagne the range we getting value is equals to zero.
#+begin_src c
#include <stdio.h>

int main(){
  unsigned int var = 4294967296;
  printf("%u", var);
  return 0;
}
#+end_src
Output:
#+begin_src output
0
#+end_src

We are having the value from 0 to 7 for a 3 bit representation the minimum value would be equals to 0 and the maximum value is equals to 7.
| 2^2 | 2^1 | 2^0 | 3 bit |
|   0 |   0 |   0 |     0 |
|   0 |   0 |   1 |     1 |
|   0 |   1 |   0 |     2 |
|   0 |   1 |   1 |     3 |
|   1 |   0 |   0 |     4 |
|   1 |   0 |   1 |     5 |
|   1 |   1 |   0 |     6 |
|   1 |   1 |   1 |     7 |

When we try to represent the value 1 greater than 7 that is 8 if you want be able to represent this value 8 in a 3 bit representation as you can see foruth.

| 2^3 | 2^2 | 2^1 | 2^0 | 3 bit |
|   0 |   0 |   0 |   0 |     0 |
|   0 |   0 |   0 |   1 |     1 |
|   0 |   0 |   1 |   0 |     2 |
|   0 |   0 |   1 |   1 |     3 |
|   0 |   1 |   0 |   0 |     4 |
|   0 |   1 |   0 |   1 |     5 |
|   0 |   1 |   1 |   0 |     6 |
|   0 |   1 |   1 |   1 |     7 |
|   1 |   0 |   0 |   0 |     8 | -> 0 0 0

For 32 bit unsigned data -> Mod 2^32
For n bit unsigned data -> Mod 2^n
#+begin_src c
#include <stdio.h>

int main() {
  int var = 2147483648;
  printf("%d", var);
  return 0;
}
#+end_src
Output
#+begin_src output
main.c: In function ‚Äòmain‚Äô:
main.c:8:15: warning: overflow in conversion from ‚Äòlong int‚Äô to ‚Äòint‚Äô changes value from ‚Äò2147483648‚Äô to ‚Äò-2147483648‚Äô [-Woverflow]
    8 |     int var = 2147483648;
      |               ^~~~~~~~~~
#+end_src

#+begin_src c
#include <stdio.h>

int main() {
  int var = -2147483649;
  printf("%d", var);
  return 0;
}
#+end_src
Output:
#+begin_src output
main.c: In function ‚Äòmain‚Äô:
main.c:8:15: warning: overflow in conversion from ‚Äòlong int‚Äô to ‚Äòint‚Äô changes value from ‚Äò-2147483649‚Äô to ‚Äò2147483647‚Äô [-Woverflow]
    8 |     int var = -2147483649;
      |               ^
#+end_src

* Fundamental Data Types - Character
** OUTLINE
- Brief overview on character data type.
- Size of characters.
- Range of characters.
- Difference between signed and unsigned characters.

** OVERVIEW
|        H |        E |        L |        L |        O |       ! |
| 01001000 | 01100101 | 01101100 | 01101100 | 01101111 | 0010001 |
Computer is capable to understand only 0 and 1. Therefor, we need to represent characters in 0 and 1 form only. But we don't need to bother about it. Because internally, all are represented in bits form only. To encode characters, there are several encoding schemes available. But one of the most commaon encoding scheme is ~ASCII~. [[https://www.ascii-code.com/][here]]

*HOW WE DEFINE AND DECLARE A CHARACTER VARIABLE*
=char some_variable_name = 'N';=
I have declared a variable of character data type ~char~ and assigned it a character ~N~.
NOTE:üìçRemember to put single quotes '' and *not* double quotes ""
You can also assign integer values to them. For example
=char some_variable_name = 65;=
I have provided a value 65. Now, this value acts like a charcater, when we are going to print it of this variable we get a character instedad of an integer.

#+begin_src c
#include <stdio.h>

int main(){
  char var = 65;
  printf("%c", var);
  return 0;
}
#+end_src
Output:
#+begin_src output
A
#+end_src

** SIZE AND RANGE OF CHARACTER
*** Size:
- 1 byte = 8 bits
*** Range:
- Unsigned: 0 to 255
- Signed: -128 to +127

** SIGNED VS UNSIGNED
-128 =
|----+---+---+---+---+---+---+---|
|  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| -2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
|  1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
+128 =
|---+---+---+---+---+---+---+---|
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
-127 =
|----+---+---+---+---+---+---+---|
|  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| -2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
|  1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
+129 =
|---+---+---+---+---+---+---+---|
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |
-1 =
|----+---+---+---+---+---+---+---|
|  7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| -2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
|  1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
+255 =
|---+---+---+---+---+---+---+---|
| 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
| 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 |
| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |

#+begin_src c
#include <stdio.h>

int main(){
  char var = -128;
  printf("%c", var);
  return 0;
}
#+end_src

** SUMMARY
- Size of character = 1 byte
- Signed character range: -128 to +127
- Unsigned character range: 0 to 255
- Negative values won't byt you any additional powers
- In traditional ASCII table, each character requires 7 bits.
- In extended ASCII table, each character utilize all 8 bits.
